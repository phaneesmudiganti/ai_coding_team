import subprocess
from doctest import testfile
import os
import logging

logger = logging.getLogger(__name__)

def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        text = f.read()
        logger.info("file read")
    return text

def _walk_repo(root: str):
    tree = []
    for dirpath, _, filenames in os.walk(root):
        for f in filenames:
            rel = os.path.relpath(os.path.join(dirpath, f), root)
            tree.append(rel)
    return tree

class GenerationOps:

    @staticmethod
    def write_plan(requirements_text: str, project_name: str, output_dir: str, file_name: str, content: str):
        os.makedirs(output_dir, exist_ok=True)
        plan_path = os.path.join(output_dir, file_name)

        with open(plan_path, "w", encoding="utf-8") as f:
            f.write(f"# {project_name} Requirements Synthesis\n\n")
            f.write("### Initial Requirements\n\n")
            f.write(requirements_text)
            f.write("\n\n")
            f.write("### Finalized Requirements\n\n")
            f.write(content)

        logger.info(f"Structured plan written to: {plan_path}")
        return f"Structured plan file created: {plan_path}"

    
    @staticmethod
    def write_architecture(project_name: str, output_dir: str, file_name: str, content: str):
        os.makedirs(output_dir, exist_ok=True)
        arch_path = os.path.join(output_dir, file_name)
        
        with open(arch_path, "w", encoding="utf-8") as f:
            f.write(f"# {project_name} Architecture\n\n")
            f.write(content)

        logger.info(f"architecture written to file: {arch_path}")
        return f"Architecture file created: {arch_path}"

    @staticmethod
    def write_code(module_name: str, project_name: str, output_dir: str, code_stub: str = ""):
        logger.info("Variables inside generation.py --> write_code method")
        logger.info(f"Module Name: {module_name}")
        logger.info(f"Project Name: {project_name}")
        logger.info(f"Output Directory: {output_dir}")

        os.makedirs(output_dir, exist_ok=True)
        file_path = os.path.join(output_dir, module_name)

        with open(file_path, "w", encoding="utf-8") as f:
            f.write(code_stub or "# Code will be generated by Agent.\n")
        logger.info("code file created")
        return f"Code file created: {file_path}"

    @staticmethod
    def write_docs(project_name: str, output_dir: str, content: str = ""):
        os.makedirs(output_dir, exist_ok=True)
        doc_path = os.path.join(output_dir, f"{project_name}_docs.md")
        with open(doc_path, "w", encoding="utf-8") as f:
            f.write(content or "# Documentation will be generated by Agent.\n")
        logger.info("docs written")
        return f"Documentation initialized: {doc_path}"

    @staticmethod
    def create_project_folder(output_dir: str):
        os.makedirs(output_dir, exist_ok=True)
        logger.info("folder created")
        return f"Created folder: {output_dir}"

    @staticmethod
    def generate_tests(module_name: str, project_name: str, output_dir: str, test_stub: str = ""):        
        test_dir = os.path.join(output_dir, "tests")
        os.makedirs(test_dir, exist_ok=True)
        test_path = os.path.join(test_dir, f"test_{project_name}_{module_name}.py")
        if not os.path.exists(test_path):
            with open(test_path, "w", encoding="utf-8") as f:
                f.write(test_stub or "# Tests will be generated by Agent.\n")
        logger.info("test file created")
        return f"Test file created: {test_path}"
    
    @staticmethod
    def run_tests(repo_path: str):
        try:
            result = subprocess.run(
                ["pytest", repo_path],
                capture_output=True,
                text=True,
                check=True
            )
            logger.info("tests run succeeded")
            return result.stdout
        except subprocess.CalledProcessError as e:
            logger.exception("tests run failed")
            return f"Error running tests: {e.stderr}"
    
    @staticmethod
    def review_repo(repo_path: str):
        result = {
            "repo_path": repo_path,
            "structure": _walk_repo(repo_path),
        }
        logger.info("repo review started")

        # Optionally run linting; adjust command to your stack (flake8, ruff, eslint, etc.)
        try:
            lint = subprocess.run(
                ["flake8", repo_path],
                capture_output=True,
                text=True,
            )
            result["lint_output"] = lint.stdout or lint.stderr or "flake8 completed with no output."
            logger.info("lint executed")
        except FileNotFoundError:
            result["lint_output"] = "flake8 not found. Skipping lint step."
        except Exception as e:
            result["lint_output"] = f"Error running flake8: {e}"
            logger.exception("lint failed")

        # Optionally run tests again from reviewer context
        try:
            pytest = subprocess.run(
                ["pytest", "-q"],
                cwd=repo_path,
                capture_output=True,
                text=True,
            )
            result["test_output"] = (
                f"STDOUT:\n{pytest.stdout}\n\nSTDERR:\n{pytest.stderr}\nReturn code: {pytest.returncode}"
            )
            logger.info("pytest executed")
        except FileNotFoundError:
            result["test_output"] = "pytest not found. Skipping test execution."
        except Exception as e:
            result["test_output"] = f"Error running pytest: {e}"
            logger.exception("pytest failed")

        logger.info("repo review finished")
        return result
